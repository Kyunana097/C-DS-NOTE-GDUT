### 2.2.1 线性表的顺序存储结构
采用顺序储存结构储存的线性表通常简称为**顺序表**，可将顺序表归纳为:**关系线性化**，**结点顺序化**
#### 1.地址的计算
一、符号约定
| 符号 | 含义 | 单位 |
|---|---|---|
| LOC(i) | 元素 ai 的内存起始地址 | 字节 |
| B | 基地址（首元素地址 LOC(0)） | 字节 |
| k | 每个元素大小（sizeof(ElemType)） | 字节 |
| i | 元素逻辑下标（从 0 开始） | 无单位 |
| n | 表长 | 无单位 |
二、一维线性表（向量）
1. 下标→地址
 LOC(i) = B + i·k (0 ≤ i ≤ n-1)
2. 地址→下标
 i = (addr – B) / k （整型除法，需保证 addr 对齐）

### 2.2.2 线性表顺序存储结构上的基本运算

#### 1. 查找操作

1. 按序号查找（GetData(L,i)）

**定义**：
获取线性表 `L` 中第 `i` 个元素的值（`1 ≤ i ≤ L.length`）。

**操作说明**：

- 若 `i` 超出范围（`i < 1` 或 `i > L.length`），则返回错误（如 `ERROR` 或抛出异常）。
- 时间复杂度：**O(1)**（随机访问特性）。

2. 按内容查找（Locate(L,e)）

**定义**：
在线性表 `L` 中查找第一个值等于 `e` 的元素，并返回其**位置序号**（从1开始）。若不存在，返回0。

**操作说明**：

- 从第一个元素开始顺序遍历，比较每个元素的值是否与 `e` 相等。
- 时间复杂度：**O(n)**（最坏需遍历整个表）。

#### 2. 插入操作

**定义**：

在线性表 `L` 的第 `i` 个位置（`1 ≤ i ≤ L.length+1`）插入新元素 `e`，使原表长度增加 1。

**前提条件**：

- 表未满（`L.length < MAXSIZE`）。
- 插入位置合法（`1 ≤ i ≤ L.length+1`）。

**操作步骤**：

1. **合法性检查**：若 `i` 越界或表满，返回错误。
2. **移动元素**：将第 `i` 个位置及之后的所有元素后移一位（从最后一个元素开始）。
3. **插入元素**：将 `e` 放入第 `i` 个位置（数组下标 `i-1`）。
4. **更新长度**：表长 `L.length` 加 1。

**时间复杂度**：

- 最坏情况（插入表头）：**O(n)**（需移动所有元素）。
- 最好情况（插入表尾）：**O(1)**（无需移动）。

| 维度         | 头插法                               | 尾插法                      |
| ------------ | ------------------------------------ | --------------------------- |
| 核心口诀     | 新节点当“新脑袋”                     | 新节点接“老屁股”            |
| 额外指针     | 只需 head                            | head + tail（或带尾结点）   |
| 时间/次      | O(1)                                 | O(1)                        |
| 顺序 vs 输入 | 逆序                                 | 顺序一致                    |
| 适用场景     | ①逆序输出 ②栈/队列的“栈顶” ③高频头插 | ①顺序保存 ②队列尾部 ③日志流 |
| 代码长度     | 最短 3 行                            | 多 1 个 tail 变量           |
| 边界情况     | 永远不用判空（新节点就是头）         | 第一次插入需特判空表        |

#### 一、头插法详解

1. 算法思路
	新节点 `p` 的 next 指向当前头，再把头指针移到 `p`——相当于“把新节点推上最前面”。
2. 完整函数（数组版）

```c
Node *create_list_head(int *a, int n)
{
    Node *head = NULL;
    for (int i = 0; i < n; ++i)
    {
        Node *p = (Node*)malloc(sizeof(Node));
        p->data = a[i];
        p->next = head;
        head = p;
    }
    return head;
}
```

3. 边界优势

- 空表、非空表同一套代码，无需 if-else。
- 天然实现“栈”：push = 头插，pop = 头删。

#### 二、尾插法详解

1. 算法思路
	保存尾指针 `tail`，新节点挂在 `tail->next`，再把 `tail` 后移；空表时头尾同时指向新节点。

2. 完整函数

	```c
	Node *create_list_tail(int *a, int n)
	{
	    Node *head = NULL, *tail = NULL;
	    for (int i = 0; i < n; ++i)
	    {
	        Node *p = (Node*)malloc(sizeof(Node));
	        p->data = a[i];
	        p->next = NULL;
	        if (head == NULL)
	            head = tail = p;
	        else
	        {
	            tail->next = p;
	            tail = p;
	        }
	    }
	    return head;
	}
	```

3. 常见优化

- **带空头结点**：事先 `head = malloc(Node)`，头结点不存数据，尾插代码可去掉空表判断，逻辑更清爽。
- **循环链表**：`tail->next = head`，O(1) 时间访问头尾，适合队列。

#### 3. 删除操作

