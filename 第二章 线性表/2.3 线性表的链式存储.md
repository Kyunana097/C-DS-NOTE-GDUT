# 2.3 线性表的链式存储结构

用任意存储块 + 指针表示逻辑次序，malloc 随时申请，free 随时释放。

## 2.3.1 单链表

### 1 结点定义
typedef struct Node {
    ElemType data;
    struct Node *next;
} Node, *LinkList;

### 2 建表
| 方法   | 链序 vs 输入 | 核心   | 复杂度 |
| ------ | ------------ | ------ | ------ |
| 头插法 | 逆序         | 新当头 | O(n)   |
| 尾插法 | 一致         | 新接尾 | O(n)   |

头插法代码：
LinkList create_head(ElemType *a,int n){
    LinkList head=NULL;
    for(int i=0;i<n;i++){
        Node *p=(Node*)malloc(sizeof(Node));
        p->data=a[i]; p->next=head; head=p;
    }
    return head;
}

尾插法代码：
LinkList create_tail(ElemType *a,int n){
    Node *head=NULL,*tail=NULL;
    for(int i=0;i<n;i++){
        Node *p=(Node*)malloc(sizeof(Node));
        p->data=a[i]; p->next=NULL;
        if(!head) head=tail=p;
        else{ tail->next=p; tail=p; }
    }
    return head;
}

### 3 查找
按序号：走 i-1 步，O(n)  
按值：顺序比较，返回首匹配指针，O(n)

### 4 插入（后插）
s->next=p->next; p->next=s;   // O(1)

### 5 删除
按位序（带头结点）：
bool ListDelete_L(LinkList L,int i,ElemType *e){
    Node *p=L; int j=0;
    while(p&&j<i-1){p=p->next;j++;}
    if(!p||!p->next)return false;
    Node *q=p->next; *e=q->data;
    p->next=q->next; free(q);
    return true;
}
按值删除首结点：
bool DelVal_L(LinkList L,ElemType val){
    Node *pre=L,*p=L->next;
    while(p&&p->data!=val){pre=p;p=p->next;}
    if(!p)return false;
    pre->next=p->next; free(p);
    return true;
}
复杂度：查找 O(n) + 删除 O(1)

### 6 清空/销毁
void DestroyList(LinkList *L){
    Node *p=*L;
    while(p){ Node *q=p; p=p->next; free(q); }
    *L=NULL;
}

### 7 特点
优点：插入/删除 O(1)（已知前驱）、无溢出、动态扩容  
缺点：无随机访问、额外指针域、缓存不友好

### 8 实战技巧
1. 带头结点：统一空/非空判断  
2. 循环链表：尾指针 rear，rear->next 得头，适合队列  
3. 双向链表：加 prior 指针，删除前驱 O(1)  
4. 调试：free 后立即置 NULL，Valgrind 查泄漏